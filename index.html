<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snake Riddles</title>
    <script src="https://cdn.jsdelivr.net/npm/@supabase/supabase-js@2"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            padding: 10px;
            touch-action: none;
            overflow: hidden;
        }

        h1 {
            margin-bottom: 10px;
            font-size: 2em;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            max-width: 100%;
        }

        #riddle-box {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px 25px;
            text-align: center;
            width: 100%;
            max-width: 400px;
            border: 2px solid rgba(0, 255, 136, 0.3);
        }

        #riddle-text {
            font-size: 1.2em;
            margin-bottom: 8px;
            line-height: 1.4;
            direction: ltr;
            unicode-bidi: plaintext;
        }

        #hint {
            color: #00ff88;
            font-size: 0.85em;
        }

        #game-canvas {
            border: 3px solid #00ff88;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
            touch-action: none;
            max-width: 100%;
            max-height: 60vh;
        }

        .stats {
            display: flex;
            gap: 20px;
            font-size: 1em;
            flex-wrap: wrap;
            justify-content: center;
        }

        .stat {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 16px;
            border-radius: 10px;
        }

        .stat-value {
            color: #00ff88;
            font-weight: bold;
        }

        #message {
            font-size: 1.3em;
            min-height: 35px;
            text-align: center;
        }

        .controls {
            color: #888;
            font-size: 0.85em;
            text-align: center;
        }

        #start-btn, .btn {
            background: #00ff88;
            color: #1a1a2e;
            border: none;
            padding: 12px 35px;
            font-size: 1.1em;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #start-btn:hover, .btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        #start-btn:active, .btn:active {
            transform: scale(0.98);
        }

        .game-over #message {
            color: #ff6b6b;
        }

        .modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.8);
            z-index: 1000;
            align-items: center;
            justify-content: center;
        }

        .modal.active {
            display: flex;
        }

        .modal-content {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            border: 3px solid #00ff88;
            border-radius: 20px;
            padding: 30px;
            max-width: 90%;
            width: 400px;
            text-align: center;
            box-shadow: 0 0 50px rgba(0, 255, 136, 0.3);
            max-height: 90vh;
            overflow-y: auto;
        }

        .modal h2 {
            color: #ff6b6b;
            margin-bottom: 20px;
            font-size: 1.8em;
        }

        .modal .final-score {
            font-size: 3em;
            color: #00ff88;
            margin: 20px 0;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .modal input {
            width: 100%;
            padding: 15px;
            font-size: 1.2em;
            border: 2px solid #00ff88;
            border-radius: 10px;
            background: rgba(255, 255, 255, 0.1);
            color: #fff;
            text-align: center;
            margin: 15px 0;
            outline: none;
        }

        .modal input:focus {
            box-shadow: 0 0 15px rgba(0, 255, 136, 0.5);
        }

        .modal input::placeholder {
            color: rgba(255, 255, 255, 0.5);
        }

        .leaderboard {
            margin-top: 20px;
            text-align: right;
            max-height: 250px;
            overflow-y: auto;
        }

        .leaderboard h3 {
            color: #ffc832;
            margin-bottom: 15px;
            font-size: 1.3em;
        }

        .leaderboard-entry {
            display: flex;
            justify-content: space-between;
            align-items: center;
            padding: 10px 15px;
            margin: 5px 0;
            background: rgba(255, 255, 255, 0.05);
            border-radius: 8px;
            transition: background 0.2s;
        }

        .leaderboard-entry:nth-child(2) {
            background: rgba(255, 215, 0, 0.2);
            border: 1px solid gold;
        }

        .leaderboard-entry:nth-child(3) {
            background: rgba(192, 192, 192, 0.15);
            border: 1px solid silver;
        }

        .leaderboard-entry:nth-child(4) {
            background: rgba(205, 127, 50, 0.15);
            border: 1px solid #cd7f32;
        }

        .leaderboard-entry.highlight {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00ff88;
        }

        .rank {
            font-weight: bold;
            color: #ffc832;
            min-width: 30px;
        }

        .player-name {
            flex: 1;
            margin: 0 10px;
            color: #fff;
        }

        .player-score {
            color: #00ff88;
            font-weight: bold;
        }

        .btn-secondary {
            background: transparent;
            border: 2px solid #00ff88;
            color: #00ff88;
            margin-top: 10px;
        }

        .btn-group {
            display: flex;
            gap: 10px;
            margin-top: 20px;
            justify-content: center;
            flex-wrap: wrap;
        }

        .global-badge {
            background: linear-gradient(135deg, #ffc832, #ff6b6b);
            color: #1a1a2e;
            padding: 3px 8px;
            border-radius: 5px;
            font-size: 0.7em;
            font-weight: bold;
            margin-left: 5px;
        }

        .loading {
            color: #888;
            padding: 20px;
            text-align: center;
        }
    </style>
</head>
<body>
    <h1>ğŸ Snake Riddles ğŸ§©</h1>

    <div class="game-container">
        <div id="riddle-box">
            <div id="riddle-text">×¤×ª×•×¨ ××ª ×”×—×™×“×” ×•××›×•×œ ××ª ×”×ª×©×•×‘×” ×”× ×›×•× ×”!</div>
            <div id="hint"></div>
        </div>

        <canvas id="game-canvas" width="400" height="400"></canvas>

        <div class="stats">
            <div class="stat">× ×™×§×•×“: <span class="stat-value" id="score">0</span></div>
            <div class="stat">×©×œ×‘: <span class="stat-value" id="level">1</span></div>
            <div class="stat">××•×¨×š: <span class="stat-value" id="snake-length">3</span></div>
        </div>

        <div id="message"></div>

        <button id="start-btn">×”×ª×—×œ ××©×—×§</button>

        <div class="controls">
            ××—×©×‘: ×—×¦×™× / WASD | ×˜×œ×¤×•×Ÿ: ×”×—×œ×§ ××• ×œ×—×¥ ×œ×›×™×•×•×Ÿ
        </div>
    </div>

    <div class="modal" id="game-over-modal">
        <div class="modal-content">
            <h2>ğŸ® Game Over!</h2>
            <div id="game-over-reason"></div>
            <div class="final-score" id="final-score">0</div>
            <input type="text" id="player-name" placeholder="×”×›× ×¡ ××ª ×”×©× ×©×œ×š" maxlength="20" autocomplete="off">
            <div class="btn-group">
                <button class="btn" id="save-score-btn">×©××•×¨ × ×™×§×•×“</button>
            </div>
            <div class="leaderboard" id="leaderboard">
                <h3>ğŸ† ×˜×‘×œ×ª ×”×œ×™×’×” ×”×¢×•×œ××™×ª <span class="global-badge">GLOBAL</span></h3>
                <div id="leaderboard-entries"></div>
            </div>
            <div class="btn-group">
                <button class="btn" id="play-again-btn">×©×—×§ ×©×•×‘</button>
            </div>
        </div>
    </div>

    <script>
    (function() {
        'use strict';

        // Supabase Configuration
        const SUPABASE_URL = 'https://whpdshyifbvihfvxnqjz.supabase.co';
        const SUPABASE_KEY = 'sb_publishable_LowymS9pfWBQZXXrKuqE8A_sHQXw9cx';
        const supabase = window.supabase.createClient(SUPABASE_URL, SUPABASE_KEY);

        // DOM Elements
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const riddleText = document.getElementById('riddle-text');
        const hintEl = document.getElementById('hint');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const snakeLengthEl = document.getElementById('snake-length');
        const messageEl = document.getElementById('message');
        const startBtn = document.getElementById('start-btn');
        const gameContainer = document.querySelector('.game-container');

        const modal = document.getElementById('game-over-modal');
        const gameOverReason = document.getElementById('game-over-reason');
        const finalScoreEl = document.getElementById('final-score');
        const playerNameInput = document.getElementById('player-name');
        const saveScoreBtn = document.getElementById('save-score-btn');
        const playAgainBtn = document.getElementById('play-again-btn');
        const leaderboardEntries = document.getElementById('leaderboard-entries');

        const GRID_SIZE = 20;
        const CELL_SIZE = canvas.width / GRID_SIZE;
        const BASE_SPEED = 150;
        const MIN_SPEED = 70;
        const SPEED_DECREASE_PER_LEVEL = 10;

        let snake = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let foods = [];
        let currentRiddle = null;
        let score = 0;
        let level = 1;
        let riddlesSolved = 0;
        let gameLoopId = null;
        let gameSpeed = BASE_SPEED;
        let isGameRunning = false;
        let growPending = 0;
        let lastSavedEntry = null;

        const riddles = [
            { q: "5 + 3 = ?", a: 8, wrong: [5, 3, 7, 9] },
            { q: "10 - 4 = ?", a: 6, wrong: [4, 10, 5, 7] },
            { q: "3 Ã— 3 = ?", a: 9, wrong: [6, 3, 12, 8] },
            { q: "12 Ã· 4 = ?", a: 3, wrong: [4, 6, 2, 8] },
            { q: "7 + 8 = ?", a: 15, wrong: [14, 16, 13, 17] },
            { q: "20 - 7 = ?", a: 13, wrong: [12, 14, 11, 27] },
            { q: "4 Ã— 5 = ?", a: 20, wrong: [9, 15, 25, 18] },
            { q: "15 Ã· 3 = ?", a: 5, wrong: [3, 6, 4, 8] },
            { q: "Next: 2, 4, 6, ?", a: 8, wrong: [7, 9, 10, 5] },
            { q: "Next: 1, 3, 5, ?", a: 7, wrong: [6, 8, 9, 4] },
            { q: "Next: 3, 6, 9, ?", a: 12, wrong: [10, 11, 13, 15] },
            { q: "×™××™× ×‘×©×‘×•×¢?", a: 7, wrong: [5, 6, 8, 10] },
            { q: "×—×•×“×©×™× ×‘×©× ×”?", a: 12, wrong: [10, 11, 13, 14] },
            { q: "×“×§×•×ª ×‘×©×¢×”?", a: 60, wrong: [30, 45, 50, 100] },
            { q: "×¦×œ×¢×•×ª ×‘××©×•×œ×©?", a: 3, wrong: [2, 4, 5, 6] },
            { q: "×¦×œ×¢×•×ª ×‘×¨×™×‘×•×¢?", a: 4, wrong: [3, 5, 6, 8] },
            { q: "25 + 17 = ?", a: 42, wrong: [40, 43, 41, 38] },
            { q: "6 Ã— 7 = ?", a: 42, wrong: [36, 48, 35, 49] },
            { q: "××¤×¡×™× ×‘-100?", a: 2, wrong: [1, 3, 0, 4] },
            { q: "×¢×™× ×™×™× ×œ×¢×›×‘×™×©?", a: 8, wrong: [2, 4, 6, 10] },
        ];

        // Global Leaderboard Functions
        async function getLeaderboard() {
            try {
                const { data, error } = await supabase
                    .from('leaderboard')
                    .select('*')
                    .order('score', { ascending: false })
                    .limit(10);
                
                if (error) throw error;
                return data || [];
            } catch (e) {
                console.error('Failed to fetch leaderboard:', e);
                return [];
            }
        }

        async function addScore(name, score) {
            try {
                const { data, error } = await supabase
                    .from('leaderboard')
                    .insert([{ player_name: name.trim() || '×× ×•× ×™××™', score: score }])
                    .select()
                    .single();
                
                if (error) throw error;
                return data;
            } catch (e) {
                console.error('Failed to save score:', e);
                return null;
            }
        }

        async function renderLeaderboard(highlightId = null) {
            leaderboardEntries.innerHTML = '<div class="loading">×˜×•×¢×Ÿ ×˜×‘×œ×” ×¢×•×œ××™×ª...</div>';
            
            const leaderboard = await getLeaderboard();
            leaderboardEntries.innerHTML = '';

            if (leaderboard.length === 0) {
                leaderboardEntries.innerHTML = '<div style="color: #888; padding: 20px;">××™×Ÿ ×¢×“×™×™×Ÿ × ×™×§×•×“×™×. ×ª×”×™×” ×”×¨××©×•×Ÿ! ğŸ†</div>';
                return;
            }

            leaderboard.forEach((entry, index) => {
                const div = document.createElement('div');
                div.className = 'leaderboard-entry';
                
                if (highlightId && entry.id === highlightId) {
                    div.classList.add('highlight');
                }

                const medal = index === 0 ? 'ğŸ¥‡' : index === 1 ? 'ğŸ¥ˆ' : index === 2 ? 'ğŸ¥‰' : `${index + 1}.`;
                
                div.innerHTML = `
                    <span class="rank">${medal}</span>
                    <span class="player-name">${escapeHtml(entry.player_name)}</span>
                    <span class="player-score">${entry.score}</span>
                `;
                leaderboardEntries.appendChild(div);
            });
        }

        function escapeHtml(text) {
            const div = document.createElement('div');
            div.textContent = text;
            return div.innerHTML;
        }

        function shuffleArray(arr) {
            const result = [...arr];
            for (let i = result.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [result[i], result[j]] = [result[j], result[i]];
            }
            return result;
        }

        function isSnakeAt(x, y) {
            return snake.some(seg => seg.x === x && seg.y === y);
        }

        function getRandomRiddle() {
            const available = riddles.filter(r => r !== currentRiddle);
            return available[Math.floor(Math.random() * available.length)];
        }

        function getRandomPosition() {
            return {
                x: Math.floor(Math.random() * (GRID_SIZE - 2)) + 1,
                y: Math.floor(Math.random() * (GRID_SIZE - 2)) + 1
            };
        }

        function isPositionValid(pos, existingPositions) {
            if (isSnakeAt(pos.x, pos.y)) return false;
            if (existingPositions.some(p => p.x === pos.x && p.y === pos.y)) return false;
            const head = snake[0];
            if (Math.abs(pos.x - head.x) < 2 && Math.abs(pos.y - head.y) < 2) return false;
            return true;
        }

        function spawnFoods() {
            foods = [];
            const allNumbers = shuffleArray([currentRiddle.a, ...currentRiddle.wrong]);
            const positions = [];

            for (const num of allNumbers) {
                let pos;
                let attempts = 0;
                do {
                    pos = getRandomPosition();
                    attempts++;
                } while (attempts < 100 && !isPositionValid(pos, positions));

                positions.push(pos);
                foods.push({
                    x: pos.x,
                    y: pos.y,
                    value: num,
                    isCorrect: num === currentRiddle.a
                });
            }
        }

        function speakRiddle(text) {
            if ('speechSynthesis' in window) {
                speechSynthesis.cancel();
                
                let spokenText = text
                    .replace(/\+/g, ' ×•×¢×•×“ ')
                    .replace(/-/g, ' ×¤×—×•×ª ')
                    .replace(/Ã—/g, ' ×›×¤×•×œ ')
                    .replace(/Ã·/g, ' ×—×œ×§×™ ')
                    .replace(/=/g, ' ×©×•×•×” ')
                    .replace(/\?/g, '?');
                
                const utterance = new SpeechSynthesisUtterance(spokenText);
                utterance.lang = 'he-IL';
                utterance.rate = 0.9;
                utterance.pitch = 1.1;
                
                const voices = speechSynthesis.getVoices();
                const hebrewVoice = voices.find(v => v.lang.includes('he'));
                if (hebrewVoice) {
                    utterance.voice = hebrewVoice;
                }
                
                speechSynthesis.speak(utterance);
            }
        }

        function setNewRiddle() {
            currentRiddle = getRandomRiddle();
            riddleText.textContent = currentRiddle.q;
            hintEl.textContent = "××¦× ×•××›×•×œ ××ª ×”×ª×©×•×‘×” ×”× ×›×•× ×”!";
            spawnFoods();
            speakRiddle(currentRiddle.q);
        }

        function initGame() {
            snake = [
                { x: 10, y: 10 },
                { x: 9, y: 10 },
                { x: 8, y: 10 }
            ];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            level = 1;
            riddlesSolved = 0;
            gameSpeed = BASE_SPEED;
            growPending = 0;
            lastSavedEntry = null;

            updateStats();
            showMessage('', '#00ff88');
            setNewRiddle();
        }

        function updateStats() {
            scoreEl.textContent = score;
            levelEl.textContent = level;
            snakeLengthEl.textContent = snake.length;
        }

        function showMessage(text, color) {
            messageEl.textContent = text;
            messageEl.style.color = color || '#fff';
        }

        function draw() {
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL_SIZE, 0);
                ctx.lineTo(i * CELL_SIZE, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * CELL_SIZE);
                ctx.lineTo(canvas.width, i * CELL_SIZE);
                ctx.stroke();
            }

            for (const food of foods) {
                const x = food.x * CELL_SIZE + CELL_SIZE / 2;
                const y = food.y * CELL_SIZE + CELL_SIZE / 2;

                ctx.beginPath();
                ctx.arc(x, y, CELL_SIZE / 2 - 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 200, 50, 0.3)';
                ctx.fill();
                ctx.strokeStyle = '#ffc832';
                ctx.lineWidth = 2;
                ctx.stroke();

                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(food.value, x, y);
            }

            for (let i = 0; i < snake.length; i++) {
                const segment = snake[i];
                const x = segment.x * CELL_SIZE;
                const y = segment.y * CELL_SIZE;

                const alpha = 1 - (i / snake.length) * 0.5;
                ctx.fillStyle = i === 0 ? '#00ff88' : `rgba(0, 255, 136, ${alpha})`;

                ctx.beginPath();
                ctx.roundRect(x + 1, y + 1, CELL_SIZE - 2, CELL_SIZE - 2, 5);
                ctx.fill();

                if (i === 0) {
                    ctx.fillStyle = '#1a1a2e';
                    const eyeSize = 3;
                    const eyeOffset = CELL_SIZE / 4;

                    let eye1, eye2;
                    if (direction.x === 1) {
                        eye1 = { x: x + CELL_SIZE - 6, y: y + eyeOffset };
                        eye2 = { x: x + CELL_SIZE - 6, y: y + CELL_SIZE - eyeOffset };
                    } else if (direction.x === -1) {
                        eye1 = { x: x + 6, y: y + eyeOffset };
                        eye2 = { x: x + 6, y: y + CELL_SIZE - eyeOffset };
                    } else if (direction.y === -1) {
                        eye1 = { x: x + eyeOffset, y: y + 6 };
                        eye2 = { x: x + CELL_SIZE - eyeOffset, y: y + 6 };
                    } else {
                        eye1 = { x: x + eyeOffset, y: y + CELL_SIZE - 6 };
                        eye2 = { x: x + CELL_SIZE - eyeOffset, y: y + CELL_SIZE - 6 };
                    }

                    ctx.beginPath();
                    ctx.arc(eye1.x, eye1.y, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(eye2.x, eye2.y, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function update() {
            if (!isGameRunning) return;

            direction = { ...nextDirection };

            const newHead = {
                x: snake[0].x + direction.x,
                y: snake[0].y + direction.y
            };

            if (newHead.x < 0 || newHead.x >= GRID_SIZE ||
                newHead.y < 0 || newHead.y >= GRID_SIZE) {
                gameOver("× ×’×¢×ª ×‘×§×™×¨!");
                return;
            }

            if (isSnakeAt(newHead.x, newHead.y)) {
                gameOver("××›×œ×ª ××ª ×¢×¦××š!");
                return;
            }

            snake.unshift(newHead);

            const eatenFoodIndex = foods.findIndex(f => f.x === newHead.x && f.y === newHead.y);

            if (eatenFoodIndex !== -1) {
                const eatenFood = foods[eatenFoodIndex];
                foods.splice(eatenFoodIndex, 1);

                if (eatenFood.isCorrect) {
                    growPending += 2;
                    score += 10 * level;
                    riddlesSolved++;

                    showMessage("× ×›×•×Ÿ! +" + (10 * level) + " × ×§×•×“×•×ª", '#00ff88');

                    foods = [];

                    if (riddlesSolved % 5 === 0) {
                        level++;
                        gameSpeed = Math.max(MIN_SPEED, BASE_SPEED - (level - 1) * SPEED_DECREASE_PER_LEVEL);
                        showMessage("× ×›×•×Ÿ! ×©×œ×‘ " + level + "!", '#00ff88');
                    }

                    updateStats();

                    setTimeout(() => {
                        if (isGameRunning) {
                            showMessage('', '#00ff88');
                            setNewRiddle();
                        }
                    }, 1000);

                } else {
                    showMessage("×˜×¢×•×ª! ×”×ª×©×•×‘×” ×”×™×ª×” " + currentRiddle.a, '#ff6b6b');

                    const shrinkAmount = Math.min(2, snake.length - 2);
                    for (let i = 0; i < shrinkAmount; i++) {
                        if (snake.length > 2) {
                            snake.pop();
                        }
                    }

                    foods = [];

                    score = Math.max(0, score - 5);
                    updateStats();

                    setTimeout(() => {
                        if (isGameRunning) {
                            showMessage('', '#00ff88');
                            setNewRiddle();
                        }
                    }, 1500);
                }
            }

            if (growPending > 0) {
                growPending--;
            } else {
                snake.pop();
            }

            updateStats();
            draw();

            gameLoopId = setTimeout(update, gameSpeed);
        }

        function gameOver(reason) {
            isGameRunning = false;
            if (gameLoopId) {
                clearTimeout(gameLoopId);
                gameLoopId = null;
            }

            gameContainer.classList.add('game-over');
            canvas.style.borderColor = '#ff6b6b';
            canvas.style.boxShadow = '0 0 30px rgba(255, 107, 107, 0.5)';

            gameOverReason.textContent = reason;
            finalScoreEl.textContent = score;
            playerNameInput.value = '';
            lastSavedEntry = null;
            
            saveScoreBtn.disabled = false;
            saveScoreBtn.textContent = '×©××•×¨ × ×™×§×•×“';
            
            renderLeaderboard();
            modal.classList.add('active');
            
            setTimeout(() => playerNameInput.focus(), 100);
        }

        function startGame() {
            if (gameLoopId) {
                clearTimeout(gameLoopId);
                gameLoopId = null;
            }

            modal.classList.remove('active');
            gameContainer.classList.remove('game-over');
            canvas.style.borderColor = '#00ff88';
            canvas.style.boxShadow = '0 0 30px rgba(0, 255, 136, 0.3)';

            initGame();
            draw();

            startBtn.style.display = "none";
            isGameRunning = true;
            gameLoopId = setTimeout(update, gameSpeed);
        }

        saveScoreBtn.addEventListener('click', async () => {
            if (lastSavedEntry) return;
            
            saveScoreBtn.disabled = true;
            saveScoreBtn.textContent = '×©×•××¨...';
            
            const name = playerNameInput.value.trim() || '×× ×•× ×™××™';
            lastSavedEntry = await addScore(name, score);
            
            if (lastSavedEntry) {
                saveScoreBtn.textContent = '× ×©××¨! âœ“';
                await renderLeaderboard(lastSavedEntry.id);
            } else {
                saveScoreBtn.textContent = '×©×’×™××” - × ×¡×” ×©×•×‘';
                saveScoreBtn.disabled = false;
            }
        });

        playerNameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                saveScoreBtn.click();
            }
        });

        playAgainBtn.addEventListener('click', startGame);

        function setDirection(newDir) {
            if (!isGameRunning) return;

            if (newDir.x !== 0 && direction.x !== 0) return;
            if (newDir.y !== 0 && direction.y !== 0) return;

            nextDirection = { ...newDir };
        }

        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    e.preventDefault();
                    setDirection({ x: 0, y: -1 });
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    e.preventDefault();
                    setDirection({ x: 0, y: 1 });
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    e.preventDefault();
                    setDirection({ x: -1, y: 0 });
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    e.preventDefault();
                    setDirection({ x: 1, y: 0 });
                    break;
            }
        });

        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        const MIN_SWIPE_DISTANCE = 20;
        const MAX_SWIPE_TIME = 500;

        function handleTouchStart(e) {
            if (modal.classList.contains('active')) return;
            e.preventDefault();
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchStartTime = Date.now();
        }

        function handleTouchMove(e) {
            if (modal.classList.contains('active')) return;
            e.preventDefault();
        }

        function handleTouchEnd(e) {
            if (modal.classList.contains('active')) return;
            e.preventDefault();

            if (!isGameRunning) return;
            if (e.changedTouches.length === 0) return;

            const touch = e.changedTouches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;
            const deltaTime = Date.now() - touchStartTime;

            if (deltaTime > MAX_SWIPE_TIME) return;

            const absX = Math.abs(deltaX);
            const absY = Math.abs(deltaY);

            if (absX < MIN_SWIPE_DISTANCE && absY < MIN_SWIPE_DISTANCE) {
                handleTapDirection(touch.clientX, touch.clientY);
                return;
            }

            if (absX > absY) {
                if (deltaX > 0) {
                    setDirection({ x: 1, y: 0 });
                } else {
                    setDirection({ x: -1, y: 0 });
                }
            } else {
                if (deltaY > 0) {
                    setDirection({ x: 0, y: 1 });
                } else {
                    setDirection({ x: 0, y: -1 });
                }
            }

            flashBorder();
        }

        function handleTapDirection(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = GRID_SIZE / rect.width;
            const scaleY = GRID_SIZE / rect.height;

            const tapX = (clientX - rect.left) * scaleX;
            const tapY = (clientY - rect.top) * scaleY;

            const head = snake[0];
            const deltaX = tapX - head.x;
            const deltaY = tapY - head.y;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                if (deltaX > 0) {
                    setDirection({ x: 1, y: 0 });
                } else {
                    setDirection({ x: -1, y: 0 });
                }
            } else {
                if (deltaY > 0) {
                    setDirection({ x: 0, y: 1 });
                } else {
                    setDirection({ x: 0, y: -1 });
                }
            }

            flashBorder();
        }

        function flashBorder() {
            canvas.style.borderColor = '#fff';
            setTimeout(() => {
                if (isGameRunning) {
                    canvas.style.borderColor = '#00ff88';
                }
            }, 50);
        }

        document.addEventListener('touchstart', (e) => {
            if (e.target === canvas || e.target === document.body) {
                handleTouchStart(e);
            }
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            if (e.target === canvas || e.target === document.body) {
                handleTouchMove(e);
            }
        }, { passive: false });

        document.addEventListener('touchend', (e) => {
            if (e.target === canvas || e.target === document.body) {
                handleTouchEnd(e);
            }
        }, { passive: false });

        document.addEventListener('gesturestart', e => e.preventDefault());
        document.addEventListener('gesturechange', e => e.preventDefault());
        document.addEventListener('gestureend', e => e.preventDefault());

        startBtn.addEventListener('click', startGame);
        startBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            startGame();
        });

        draw();
    })();
    </script>
</body>
</html>
