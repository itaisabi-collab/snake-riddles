<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ğŸ × ×—×© ×—×™×“×•×ª</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; -webkit-touch-callout: none; -webkit-user-select: none; user-select: none; }
        body { background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%); min-height: 100vh; display: flex; flex-direction: column; align-items: center; justify-content: center; font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif; color: #fff; padding: 20px; touch-action: manipulation; }
        h1 { margin-bottom: 10px; font-size: 2.5em; text-shadow: 0 0 20px rgba(0, 255, 136, 0.5); }
        .game-container { display: flex; flex-direction: column; align-items: center; gap: 20px; }
        #riddle-box { background: rgba(255, 255, 255, 0.1); backdrop-filter: blur(10px); border-radius: 15px; padding: 20px 30px; text-align: center; min-width: 400px; border: 2px solid rgba(0, 255, 136, 0.3); }
        #riddle-text { font-size: 1.3em; margin-bottom: 10px; line-height: 1.5; direction: ltr; unicode-bidi: plaintext; }
        #hint { color: #00ff88; font-size: 0.9em; }
        #game-canvas { border: 3px solid #00ff88; border-radius: 10px; box-shadow: 0 0 30px rgba(0, 255, 136, 0.3); touch-action: none; }
        .stats { display: flex; gap: 30px; font-size: 1.2em; }
        .stat { background: rgba(255, 255, 255, 0.1); padding: 10px 20px; border-radius: 10px; }
        .stat-value { color: #00ff88; font-weight: bold; }
        #message { font-size: 1.5em; color: #ff6b6b; min-height: 40px; }
        .controls { margin-top: 10px; color: #888; font-size: 0.9em; }
        @media (max-width: 500px) { #game-canvas { max-width: 90vw; max-height: 50vh; } h1 { font-size: 1.8em; } #riddle-box { min-width: auto; width: 90vw; padding: 15px; } #riddle-text { font-size: 1.1em; } }
        #start-btn { background: #00ff88; color: #1a1a2e; border: none; padding: 15px 40px; font-size: 1.2em; border-radius: 10px; cursor: pointer; font-weight: bold; transition: transform 0.2s, box-shadow 0.2s; }
        #start-btn:hover { transform: scale(1.05); box-shadow: 0 0 20px rgba(0, 255, 136, 0.5); }
    </style>
</head>
<body>
    <h1>ğŸ × ×—×© ×—×™×“×•×ª</h1>
    <div class="game-container">
        <div id="riddle-box"><div id="riddle-text">×¤×ª×•×¨ ××ª ×”×—×™×“×” ×•××›×•×œ ××ª ×”×ª×©×•×‘×” ×”× ×›×•× ×”!</div><div id="hint"></div></div>
        <canvas id="game-canvas" width="400" height="400"></canvas>
        <div class="stats"><div class="stat">× ×™×§×•×“: <span class="stat-value" id="score">0</span></div><div class="stat">×¨××”: <span class="stat-value" id="level">1</span></div><div class="stat">××•×¨×š: <span class="stat-value" id="snake-length">3</span></div></div>
        <div id="message"></div>
        <button id="start-btn">×”×ª×—×œ ××©×—×§</button>
        <div class="controls">××—×©×‘: ×—×¦×™× / WASD | ×˜×œ×¤×•×Ÿ: ×œ×—×¥ ×œ×›×™×•×•×Ÿ ×©××ª×” ×¨×•×¦×”</div>
    </div>
    <script>
const canvas = document.getElementById('game-canvas'), ctx = canvas.getContext('2d');
const riddleText = document.getElementById('riddle-text'), hintEl = document.getElementById('hint');
const scoreEl = document.getElementById('score'), levelEl = document.getElementById('level');
const snakeLengthEl = document.getElementById('snake-length'), messageEl = document.getElementById('message');
const startBtn = document.getElementById('start-btn');
const GRID_SIZE = 20, CELL_SIZE = canvas.width / GRID_SIZE;
let snake = [], direction = {x:1,y:0}, nextDirection = {x:1,y:0}, foods = [], currentRiddle = null;
let score = 0, level = 1, riddlesSolved = 0, gameLoop = null, gameSpeed = 150, waitingForNewRiddle = false;
const riddles = [
    {q:"5 + 3 = ?",a:8,wrong:[5,3,7,9]},{q:"10 - 4 = ?",a:6,wrong:[4,10,5,7]},{q:"3 Ã— 3 = ?",a:9,wrong:[6,3,12,8]},
    {q:"12 Ã· 4 = ?",a:3,wrong:[4,6,2,8]},{q:"7 + 8 = ?",a:15,wrong:[14,16,13,17]},{q:"20 - 7 = ?",a:13,wrong:[12,14,11,27]},
    {q:"4 Ã— 5 = ?",a:20,wrong:[9,15,25,18]},{q:"15 Ã· 3 = ?",a:5,wrong:[3,6,4,8]},
    {q:"×›××” ×™××™× ×‘×©×‘×•×¢?",a:7,wrong:[5,6,8,10]},{q:"×›××” ×—×•×“×©×™× ×‘×©× ×”?",a:12,wrong:[10,11,13,14]},
    {q:"×›××” ×“×§×•×ª ×‘×©×¢×”?",a:60,wrong:[30,45,50,100]},{q:"×›××” ×¦×“×“×™× ×œ××©×•×œ×©?",a:3,wrong:[2,4,5,6]},
    {q:"×›××” ×¦×“×“×™× ×œ×¨×™×‘×•×¢?",a:4,wrong:[3,5,6,8]},{q:"25 + 17 = ?",a:42,wrong:[40,43,41,38]},
    {q:"6 Ã— 7 = ?",a:42,wrong:[36,48,35,49]},{q:"×›××” ××¤×¡×™× ×‘×××”?",a:2,wrong:[1,3,0,4]}
];
function getRandomRiddle() { const a = riddles.filter(r => r !== currentRiddle); return a[Math.floor(Math.random() * a.length)]; }
function shuffleArray(arr) { for (let i = arr.length - 1; i > 0; i--) { const j = Math.floor(Math.random() * (i + 1)); [arr[i], arr[j]] = [arr[j], arr[i]]; } }
function isSnakeAt(x, y) { return snake.some(s => s.x === x && s.y === y); }
function spawnFoods() {
    foods = []; const allNumbers = [currentRiddle.a, ...currentRiddle.wrong]; shuffleArray(allNumbers);
    const positions = [];
    for (const num of allNumbers) {
        let pos, attempts = 0;
        do { pos = {x: Math.floor(Math.random() * (GRID_SIZE - 2)) + 1, y: Math.floor(Math.random() * (GRID_SIZE - 2)) + 1}; attempts++;
        } while (attempts < 100 && (isSnakeAt(pos.x, pos.y) || positions.some(p => p.x === pos.x && p.y === pos.y) || (Math.abs(pos.x - snake[0].x) < 3 && Math.abs(pos.y - snake[0].y) < 3)));
        positions.push(pos); foods.push({...pos, value: num, isCorrect: num === currentRiddle.a});
    }
}
function newRiddle() { currentRiddle = getRandomRiddle(); riddleText.textContent = currentRiddle.q; hintEl.textContent = "ğŸ¯ ××¦× ×•××›×•×œ ××ª ×”×ª×©×•×‘×” ×”× ×›×•× ×”!"; spawnFoods(); waitingForNewRiddle = false; }
function initGame() {
    snake = [{x:10,y:10},{x:9,y:10},{x:8,y:10}]; direction = {x:1,y:0}; nextDirection = {x:1,y:0};
    score = 0; level = 1; riddlesSolved = 0; gameSpeed = 150; waitingForNewRiddle = false; updateStats(); messageEl.textContent = ""; newRiddle();
}
function updateStats() { scoreEl.textContent = score; levelEl.textContent = level; snakeLengthEl.textContent = snake.length; }
function draw() {
    ctx.fillStyle = '#1a1a2e'; ctx.fillRect(0, 0, canvas.width, canvas.height);
    ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
    for (let i = 0; i <= GRID_SIZE; i++) { ctx.beginPath(); ctx.moveTo(i * CELL_SIZE, 0); ctx.lineTo(i * CELL_SIZE, canvas.height); ctx.stroke(); ctx.beginPath(); ctx.moveTo(0, i * CELL_SIZE); ctx.lineTo(canvas.width, i * CELL_SIZE); ctx.stroke(); }
    for (const food of foods) { const x = food.x * CELL_SIZE + CELL_SIZE / 2, y = food.y * CELL_SIZE + CELL_SIZE / 2; ctx.beginPath(); ctx.arc(x, y, CELL_SIZE / 2 - 2, 0, Math.PI * 2); ctx.fillStyle = 'rgba(255, 200, 50, 0.3)'; ctx.fill(); ctx.strokeStyle = '#ffc832'; ctx.lineWidth = 2; ctx.stroke(); ctx.fillStyle = '#fff'; ctx.font = 'bold 14px Arial'; ctx.textAlign = 'center'; ctx.textBaseline = 'middle'; ctx.fillText(food.value, x, y); }
    for (let i = 0; i < snake.length; i++) { const seg = snake[i], x = seg.x * CELL_SIZE, y = seg.y * CELL_SIZE; ctx.fillStyle = i === 0 ? '#00ff88' : `rgba(0, 255, 136, ${1 - (i / snake.length) * 0.5})`; ctx.beginPath(); ctx.roundRect(x + 1, y + 1, CELL_SIZE - 2, CELL_SIZE - 2, 5); ctx.fill(); if (i === 0) { ctx.fillStyle = '#1a1a2e'; const eo = CELL_SIZE / 4; if (direction.x === 1) { ctx.beginPath(); ctx.arc(x + CELL_SIZE - 5, y + eo, 3, 0, Math.PI * 2); ctx.arc(x + CELL_SIZE - 5, y + CELL_SIZE - eo, 3, 0, Math.PI * 2); ctx.fill(); } else if (direction.x === -1) { ctx.beginPath(); ctx.arc(x + 5, y + eo, 3, 0, Math.PI * 2); ctx.arc(x + 5, y + CELL_SIZE - eo, 3, 0, Math.PI * 2); ctx.fill(); } else if (direction.y === -1) { ctx.beginPath(); ctx.arc(x + eo, y + 5, 3, 0, Math.PI * 2); ctx.arc(x + CELL_SIZE - eo, y + 5, 3, 0, Math.PI * 2); ctx.fill(); } else { ctx.beginPath(); ctx.arc(x + eo, y + CELL_SIZE - 5, 3, 0, Math.PI * 2); ctx.arc(x + CELL_SIZE - eo, y + CELL_SIZE - 5, 3, 0, Math.PI * 2); ctx.fill(); } } }
}
function update() {
    direction = {...nextDirection}; const head = {x: snake[0].x + direction.x, y: snake[0].y + direction.y};
    if (head.x < 0 || head.x >= GRID_SIZE || head.y < 0 || head.y >= GRID_SIZE) { gameOver("ğŸ’¥ ×¤×’×¢×ª ×‘×§×™×¨!"); return; }
    if (isSnakeAt(head.x, head.y)) { gameOver("ğŸ”„ ××›×œ×ª ××ª ×¢×¦××š!"); return; }
    snake.unshift(head);
    if (!waitingForNewRiddle) { const idx = foods.findIndex(f => f.x === head.x && f.y === head.y);
        if (idx !== -1) { const eaten = foods[idx]; foods.splice(idx, 1);
            if (eaten.isCorrect) { score += 10 * level; riddlesSolved++; messageEl.style.color = '#00ff88'; messageEl.textContent = "âœ… × ×›×•×Ÿ! +" + (10 * level) + " × ×§×•×“×•×ª"; foods = []; waitingForNewRiddle = true; if (riddlesSolved % 5 === 0) { level++; gameSpeed = Math.max(50, gameSpeed - 15); messageEl.textContent += " | ğŸ‰ ×¨××” " + level + "!"; clearInterval(gameLoop); gameLoop = setInterval(update, gameSpeed); } updateStats(); setTimeout(() => { messageEl.textContent = ""; newRiddle(); }, 1000); }
            else { messageEl.style.color = '#ff6b6b'; messageEl.textContent = "âŒ ×œ× × ×›×•×Ÿ! ×”×ª×©×•×‘×” ×”×™× " + currentRiddle.a; if (snake.length > 3) { snake.pop(); snake.pop(); snake.pop(); } foods = []; waitingForNewRiddle = true; score = Math.max(0, score - 5); updateStats(); setTimeout(() => { messageEl.textContent = ""; newRiddle(); }, 1500); }
        } else { snake.pop(); }
    } else { snake.pop(); }
    draw();
}
function gameOver(reason) { clearInterval(gameLoop); gameLoop = null; messageEl.style.color = '#ff6b6b'; messageEl.textContent = reason + " | × ×™×§×•×“ ×¡×•×¤×™: " + score; startBtn.textContent = "ğŸ”„ ×©×—×§ ×©×•×‘"; startBtn.style.display = "block"; canvas.style.borderColor = '#ff6b6b'; canvas.style.boxShadow = '0 0 30px rgba(255, 107, 107, 0.5)'; }
function startGame() { if (gameLoop) clearInterval(gameLoop); canvas.style.borderColor = '#00ff88'; canvas.style.boxShadow = '0 0 30px rgba(0, 255, 136, 0.3)'; initGame(); draw(); startBtn.style.display = "none"; gameLoop = setInterval(update, gameSpeed); }
document.addEventListener('keydown', (e) => { if (!gameLoop) return; switch(e.key) { case 'ArrowUp': case 'w': case 'W': if (direction.y !== 1) nextDirection = {x:0,y:-1}; break; case 'ArrowDown': case 's': case 'S': if (direction.y !== -1) nextDirection = {x:0,y:1}; break; case 'ArrowLeft': case 'a': case 'A': if (direction.x !== 1) nextDirection = {x:-1,y:0}; break; case 'ArrowRight': case 'd': case 'D': if (direction.x !== -1) nextDirection = {x:1,y:0}; break; } });
startBtn.addEventListener('click', startGame);
function handleTouch(e) { e.preventDefault(); if (!gameLoop) return; const touch = e.touches ? e.touches[0] : e; const rect = canvas.getBoundingClientRect(); const tapX = (touch.clientX - rect.left) / rect.width * GRID_SIZE; const tapY = (touch.clientY - rect.top) / rect.height * GRID_SIZE; const headX = snake[0].x, headY = snake[0].y; const dx = tapX - headX, dy = tapY - headY; const checkDir = nextDirection; if (Math.abs(dx) > Math.abs(dy)) { if (dx > 0 && checkDir.x !== -1) nextDirection = {x:1,y:0}; else if (dx < 0 && checkDir.x !== 1) nextDirection = {x:-1,y:0}; } else { if (dy > 0 && checkDir.y !== -1) nextDirection = {x:0,y:1}; else if (dy < 0 && checkDir.y !== 1) nextDirection = {x:0,y:-1}; } canvas.style.borderColor = '#fff'; setTimeout(() => { if (gameLoop) canvas.style.borderColor = '#00ff88'; }, 50); }
canvas.addEventListener('touchstart', handleTouch, {passive:false}); canvas.addEventListener('click', handleTouch);
canvas.addEventListener('touchmove', e => e.preventDefault(), {passive:false}); canvas.addEventListener('touchend', e => e.preventDefault(), {passive:false});
draw();
    </script>
</body>
</html>
