<!DOCTYPE html>
<html lang="he" dir="rtl">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>Snake Riddles</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
            -webkit-touch-callout: none;
            -webkit-user-select: none;
            user-select: none;
        }

        body {
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            min-height: 100vh;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            color: #fff;
            padding: 10px;
            touch-action: none;
            overflow: hidden;
        }

        h1 {
            margin-bottom: 10px;
            font-size: 2em;
            text-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        .game-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            gap: 15px;
            max-width: 100%;
        }

        #riddle-box {
            background: rgba(255, 255, 255, 0.1);
            backdrop-filter: blur(10px);
            border-radius: 15px;
            padding: 15px 25px;
            text-align: center;
            width: 100%;
            max-width: 400px;
            border: 2px solid rgba(0, 255, 136, 0.3);
        }

        #riddle-text {
            font-size: 1.2em;
            margin-bottom: 8px;
            line-height: 1.4;
            direction: ltr;
            unicode-bidi: plaintext;
        }

        #hint {
            color: #00ff88;
            font-size: 0.85em;
        }

        #game-canvas {
            border: 3px solid #00ff88;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 255, 136, 0.3);
            touch-action: none;
            max-width: 100%;
            max-height: 60vh;
        }

        .stats {
            display: flex;
            gap: 20px;
            font-size: 1em;
            flex-wrap: wrap;
            justify-content: center;
        }

        .stat {
            background: rgba(255, 255, 255, 0.1);
            padding: 8px 16px;
            border-radius: 10px;
        }

        .stat-value {
            color: #00ff88;
            font-weight: bold;
        }

        #message {
            font-size: 1.3em;
            min-height: 35px;
            text-align: center;
        }

        .controls {
            color: #888;
            font-size: 0.85em;
            text-align: center;
        }

        #start-btn {
            background: #00ff88;
            color: #1a1a2e;
            border: none;
            padding: 12px 35px;
            font-size: 1.1em;
            border-radius: 10px;
            cursor: pointer;
            font-weight: bold;
            transition: transform 0.2s, box-shadow 0.2s;
        }

        #start-btn:hover {
            transform: scale(1.05);
            box-shadow: 0 0 20px rgba(0, 255, 136, 0.5);
        }

        #start-btn:active {
            transform: scale(0.98);
        }

        .game-over #message {
            color: #ff6b6b;
        }
    </style>
</head>
<body>
    <h1>Snake Riddles</h1>

    <div class="game-container">
        <div id="riddle-box">
            <div id="riddle-text">Solve the riddle and eat the correct answer!</div>
            <div id="hint"></div>
        </div>

        <canvas id="game-canvas" width="400" height="400"></canvas>

        <div class="stats">
            <div class="stat">Score: <span class="stat-value" id="score">0</span></div>
            <div class="stat">Level: <span class="stat-value" id="level">1</span></div>
            <div class="stat">Length: <span class="stat-value" id="snake-length">3</span></div>
        </div>

        <div id="message"></div>

        <button id="start-btn">Start Game</button>

        <div class="controls">
            Desktop: Arrow keys / WASD | Mobile: Swipe to change direction
        </div>
    </div>

    <script>
    (function() {
        'use strict';

        // DOM Elements
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const riddleText = document.getElementById('riddle-text');
        const hintEl = document.getElementById('hint');
        const scoreEl = document.getElementById('score');
        const levelEl = document.getElementById('level');
        const snakeLengthEl = document.getElementById('snake-length');
        const messageEl = document.getElementById('message');
        const startBtn = document.getElementById('start-btn');
        const gameContainer = document.querySelector('.game-container');

        // Game Constants
        const GRID_SIZE = 20;
        const CELL_SIZE = canvas.width / GRID_SIZE;
        const BASE_SPEED = 150;
        const MIN_SPEED = 70;
        const SPEED_DECREASE_PER_LEVEL = 10;

        // Game State
        let snake = [];
        let direction = { x: 1, y: 0 };
        let nextDirection = { x: 1, y: 0 };
        let foods = [];
        let currentRiddle = null;
        let score = 0;
        let level = 1;
        let riddlesSolved = 0;
        let gameLoopId = null;
        let gameSpeed = BASE_SPEED;
        let isGameRunning = false;
        let growPending = 0; // How many segments to grow

        // Riddles Database
        const riddles = [
            { q: "5 + 3 = ?", a: 8, wrong: [5, 3, 7, 9] },
            { q: "10 - 4 = ?", a: 6, wrong: [4, 10, 5, 7] },
            { q: "3 × 3 = ?", a: 9, wrong: [6, 3, 12, 8] },
            { q: "12 ÷ 4 = ?", a: 3, wrong: [4, 6, 2, 8] },
            { q: "7 + 8 = ?", a: 15, wrong: [14, 16, 13, 17] },
            { q: "20 - 7 = ?", a: 13, wrong: [12, 14, 11, 27] },
            { q: "4 × 5 = ?", a: 20, wrong: [9, 15, 25, 18] },
            { q: "15 ÷ 3 = ?", a: 5, wrong: [3, 6, 4, 8] },
            { q: "Next: 2, 4, 6, ?", a: 8, wrong: [7, 9, 10, 5] },
            { q: "Next: 1, 3, 5, ?", a: 7, wrong: [6, 8, 9, 4] },
            { q: "Next: 3, 6, 9, ?", a: 12, wrong: [10, 11, 13, 15] },
            { q: "Days in a week?", a: 7, wrong: [5, 6, 8, 10] },
            { q: "Months in a year?", a: 12, wrong: [10, 11, 13, 14] },
            { q: "Minutes in an hour?", a: 60, wrong: [30, 45, 50, 100] },
            { q: "Sides of a triangle?", a: 3, wrong: [2, 4, 5, 6] },
            { q: "Sides of a square?", a: 4, wrong: [3, 5, 6, 8] },
            { q: "25 + 17 = ?", a: 42, wrong: [40, 43, 41, 38] },
            { q: "6 × 7 = ?", a: 42, wrong: [36, 48, 35, 49] },
            { q: "Zeros in 100?", a: 2, wrong: [1, 3, 0, 4] },
            { q: "Eyes on a spider?", a: 8, wrong: [2, 4, 6, 10] },
        ];

        // Utility Functions
        function shuffleArray(arr) {
            const result = [...arr];
            for (let i = result.length - 1; i > 0; i--) {
                const j = Math.floor(Math.random() * (i + 1));
                [result[i], result[j]] = [result[j], result[i]];
            }
            return result;
        }

        function isSnakeAt(x, y) {
            return snake.some(seg => seg.x === x && seg.y === y);
        }

        function isFoodAt(x, y) {
            return foods.some(f => f.x === x && f.y === y);
        }

        function getRandomRiddle() {
            const available = riddles.filter(r => r !== currentRiddle);
            return available[Math.floor(Math.random() * available.length)];
        }

        function getRandomPosition() {
            return {
                x: Math.floor(Math.random() * (GRID_SIZE - 2)) + 1,
                y: Math.floor(Math.random() * (GRID_SIZE - 2)) + 1
            };
        }

        function isPositionValid(pos, existingPositions) {
            // Not on snake
            if (isSnakeAt(pos.x, pos.y)) return false;
            // Not on existing food positions
            if (existingPositions.some(p => p.x === pos.x && p.y === pos.y)) return false;
            // Not too close to snake head
            const head = snake[0];
            if (Math.abs(pos.x - head.x) < 2 && Math.abs(pos.y - head.y) < 2) return false;
            return true;
        }

        // Game Functions
        function spawnFoods() {
            foods = [];
            const allNumbers = shuffleArray([currentRiddle.a, ...currentRiddle.wrong]);
            const positions = [];

            for (const num of allNumbers) {
                let pos;
                let attempts = 0;
                do {
                    pos = getRandomPosition();
                    attempts++;
                } while (attempts < 100 && !isPositionValid(pos, positions));

                positions.push(pos);
                foods.push({
                    x: pos.x,
                    y: pos.y,
                    value: num,
                    isCorrect: num === currentRiddle.a
                });
            }
        }

        // Text-to-Speech for riddles
        function speakRiddle(text) {
            if ('speechSynthesis' in window) {
                // Cancel any ongoing speech
                speechSynthesis.cancel();
                
                // Convert math symbols to Hebrew words
                let spokenText = text
                    .replace(/\+/g, ' ועוד ')
                    .replace(/-/g, ' פחות ')
                    .replace(/×/g, ' כפול ')
                    .replace(/÷/g, ' חלקי ')
                    .replace(/=/g, ' שווה ')
                    .replace(/\?/g, '?');
                
                const utterance = new SpeechSynthesisUtterance(spokenText);
                utterance.lang = 'he-IL';
                utterance.rate = 0.9;
                utterance.pitch = 1.1;
                
                // Try to find Hebrew voice
                const voices = speechSynthesis.getVoices();
                const hebrewVoice = voices.find(v => v.lang.includes('he'));
                if (hebrewVoice) {
                    utterance.voice = hebrewVoice;
                }
                
                speechSynthesis.speak(utterance);
            }
        }

        function setNewRiddle() {
            currentRiddle = getRandomRiddle();
            riddleText.textContent = currentRiddle.q;
            hintEl.textContent = "Find and eat the correct answer!";
            spawnFoods();
            
            // Speak the riddle!
            speakRiddle(currentRiddle.q);
        }

        function initGame() {
            // Initialize snake in center
            snake = [
                { x: 10, y: 10 },
                { x: 9, y: 10 },
                { x: 8, y: 10 }
            ];
            direction = { x: 1, y: 0 };
            nextDirection = { x: 1, y: 0 };
            score = 0;
            level = 1;
            riddlesSolved = 0;
            gameSpeed = BASE_SPEED;
            growPending = 0;

            updateStats();
            showMessage('', '#00ff88');
            setNewRiddle();
        }

        function updateStats() {
            scoreEl.textContent = score;
            levelEl.textContent = level;
            snakeLengthEl.textContent = snake.length;
        }

        function showMessage(text, color) {
            messageEl.textContent = text;
            messageEl.style.color = color || '#fff';
        }

        function draw() {
            // Clear canvas
            ctx.fillStyle = '#1a1a2e';
            ctx.fillRect(0, 0, canvas.width, canvas.height);

            // Draw grid
            ctx.strokeStyle = 'rgba(255, 255, 255, 0.05)';
            ctx.lineWidth = 1;
            for (let i = 0; i <= GRID_SIZE; i++) {
                ctx.beginPath();
                ctx.moveTo(i * CELL_SIZE, 0);
                ctx.lineTo(i * CELL_SIZE, canvas.height);
                ctx.stroke();
                ctx.beginPath();
                ctx.moveTo(0, i * CELL_SIZE);
                ctx.lineTo(canvas.width, i * CELL_SIZE);
                ctx.stroke();
            }

            // Draw food
            for (const food of foods) {
                const x = food.x * CELL_SIZE + CELL_SIZE / 2;
                const y = food.y * CELL_SIZE + CELL_SIZE / 2;

                // Food circle
                ctx.beginPath();
                ctx.arc(x, y, CELL_SIZE / 2 - 2, 0, Math.PI * 2);
                ctx.fillStyle = 'rgba(255, 200, 50, 0.3)';
                ctx.fill();
                ctx.strokeStyle = '#ffc832';
                ctx.lineWidth = 2;
                ctx.stroke();

                // Food number
                ctx.fillStyle = '#fff';
                ctx.font = 'bold 14px Arial';
                ctx.textAlign = 'center';
                ctx.textBaseline = 'middle';
                ctx.fillText(food.value, x, y);
            }

            // Draw snake
            for (let i = 0; i < snake.length; i++) {
                const segment = snake[i];
                const x = segment.x * CELL_SIZE;
                const y = segment.y * CELL_SIZE;

                // Segment color (head is brightest)
                const alpha = 1 - (i / snake.length) * 0.5;
                ctx.fillStyle = i === 0 ? '#00ff88' : `rgba(0, 255, 136, ${alpha})`;

                // Draw rounded rectangle
                ctx.beginPath();
                ctx.roundRect(x + 1, y + 1, CELL_SIZE - 2, CELL_SIZE - 2, 5);
                ctx.fill();

                // Draw eyes on head
                if (i === 0) {
                    ctx.fillStyle = '#1a1a2e';
                    const eyeSize = 3;
                    const eyeOffset = CELL_SIZE / 4;

                    let eye1, eye2;
                    if (direction.x === 1) { // Right
                        eye1 = { x: x + CELL_SIZE - 6, y: y + eyeOffset };
                        eye2 = { x: x + CELL_SIZE - 6, y: y + CELL_SIZE - eyeOffset };
                    } else if (direction.x === -1) { // Left
                        eye1 = { x: x + 6, y: y + eyeOffset };
                        eye2 = { x: x + 6, y: y + CELL_SIZE - eyeOffset };
                    } else if (direction.y === -1) { // Up
                        eye1 = { x: x + eyeOffset, y: y + 6 };
                        eye2 = { x: x + CELL_SIZE - eyeOffset, y: y + 6 };
                    } else { // Down
                        eye1 = { x: x + eyeOffset, y: y + CELL_SIZE - 6 };
                        eye2 = { x: x + CELL_SIZE - eyeOffset, y: y + CELL_SIZE - 6 };
                    }

                    ctx.beginPath();
                    ctx.arc(eye1.x, eye1.y, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                    ctx.beginPath();
                    ctx.arc(eye2.x, eye2.y, eyeSize, 0, Math.PI * 2);
                    ctx.fill();
                }
            }
        }

        function update() {
            if (!isGameRunning) return;

            // Apply queued direction change
            direction = { ...nextDirection };

            // Calculate new head position
            const newHead = {
                x: snake[0].x + direction.x,
                y: snake[0].y + direction.y
            };

            // Check wall collision
            if (newHead.x < 0 || newHead.x >= GRID_SIZE ||
                newHead.y < 0 || newHead.y >= GRID_SIZE) {
                gameOver("Hit the wall!");
                return;
            }

            // Check self collision
            if (isSnakeAt(newHead.x, newHead.y)) {
                gameOver("Ate yourself!");
                return;
            }

            // Add new head
            snake.unshift(newHead);

            // Check if food was eaten
            const eatenFoodIndex = foods.findIndex(f => f.x === newHead.x && f.y === newHead.y);

            if (eatenFoodIndex !== -1) {
                const eatenFood = foods[eatenFoodIndex];
                foods.splice(eatenFoodIndex, 1);

                if (eatenFood.isCorrect) {
                    // CORRECT ANSWER - Snake GROWS
                    growPending += 2; // Grow by 2 segments for correct answer
                    score += 10 * level;
                    riddlesSolved++;

                    showMessage("Correct! +" + (10 * level) + " points", '#00ff88');

                    // Clear remaining foods
                    foods = [];

                    // Level up every 5 riddles
                    if (riddlesSolved % 5 === 0) {
                        level++;
                        gameSpeed = Math.max(MIN_SPEED, BASE_SPEED - (level - 1) * SPEED_DECREASE_PER_LEVEL);
                        showMessage("Correct! Level " + level + "!", '#00ff88');
                    }

                    updateStats();

                    // Set new riddle after delay
                    setTimeout(() => {
                        if (isGameRunning) {
                            showMessage('', '#00ff88');
                            setNewRiddle();
                        }
                    }, 1000);

                } else {
                    // WRONG ANSWER - Snake SHRINKS
                    showMessage("Wrong! Answer was " + currentRiddle.a, '#ff6b6b');

                    // Shrink snake (remove 2 segments, but keep minimum 2)
                    const shrinkAmount = Math.min(2, snake.length - 2);
                    for (let i = 0; i < shrinkAmount; i++) {
                        if (snake.length > 2) {
                            snake.pop();
                        }
                    }

                    // Clear remaining foods
                    foods = [];

                    score = Math.max(0, score - 5);
                    updateStats();

                    // Set new riddle after delay
                    setTimeout(() => {
                        if (isGameRunning) {
                            showMessage('', '#00ff88');
                            setNewRiddle();
                        }
                    }, 1500);
                }
            }

            // Handle tail: grow if pending, otherwise remove tail
            if (growPending > 0) {
                growPending--;
                // Don't remove tail = snake grows
            } else {
                snake.pop();
            }

            updateStats();
            draw();

            // Schedule next update
            gameLoopId = setTimeout(update, gameSpeed);
        }

        function gameOver(reason) {
            isGameRunning = false;
            if (gameLoopId) {
                clearTimeout(gameLoopId);
                gameLoopId = null;
            }

            gameContainer.classList.add('game-over');
            showMessage(reason + " Final score: " + score, '#ff6b6b');
            startBtn.textContent = "Play Again";
            startBtn.style.display = "block";

            canvas.style.borderColor = '#ff6b6b';
            canvas.style.boxShadow = '0 0 30px rgba(255, 107, 107, 0.5)';
        }

        function startGame() {
            if (gameLoopId) {
                clearTimeout(gameLoopId);
                gameLoopId = null;
            }

            gameContainer.classList.remove('game-over');
            canvas.style.borderColor = '#00ff88';
            canvas.style.boxShadow = '0 0 30px rgba(0, 255, 136, 0.3)';

            initGame();
            draw();

            startBtn.style.display = "none";
            isGameRunning = true;
            gameLoopId = setTimeout(update, gameSpeed);
        }

        // Input: Set direction (with validation)
        function setDirection(newDir) {
            if (!isGameRunning) return;

            // Prevent 180-degree turns
            if (newDir.x !== 0 && direction.x !== 0) return;
            if (newDir.y !== 0 && direction.y !== 0) return;

            nextDirection = { ...newDir };
        }

        // Keyboard Controls
        document.addEventListener('keydown', (e) => {
            switch(e.key) {
                case 'ArrowUp':
                case 'w':
                case 'W':
                    e.preventDefault();
                    setDirection({ x: 0, y: -1 });
                    break;
                case 'ArrowDown':
                case 's':
                case 'S':
                    e.preventDefault();
                    setDirection({ x: 0, y: 1 });
                    break;
                case 'ArrowLeft':
                case 'a':
                case 'A':
                    e.preventDefault();
                    setDirection({ x: -1, y: 0 });
                    break;
                case 'ArrowRight':
                case 'd':
                case 'D':
                    e.preventDefault();
                    setDirection({ x: 1, y: 0 });
                    break;
            }
        });

        // Touch Controls - Swipe based
        let touchStartX = 0;
        let touchStartY = 0;
        let touchStartTime = 0;
        const MIN_SWIPE_DISTANCE = 20;
        const MAX_SWIPE_TIME = 500;

        function handleTouchStart(e) {
            e.preventDefault();
            const touch = e.touches[0];
            touchStartX = touch.clientX;
            touchStartY = touch.clientY;
            touchStartTime = Date.now();
        }

        function handleTouchMove(e) {
            e.preventDefault();
        }

        function handleTouchEnd(e) {
            e.preventDefault();

            if (!isGameRunning) return;
            if (e.changedTouches.length === 0) return;

            const touch = e.changedTouches[0];
            const deltaX = touch.clientX - touchStartX;
            const deltaY = touch.clientY - touchStartY;
            const deltaTime = Date.now() - touchStartTime;

            // Must be a quick swipe
            if (deltaTime > MAX_SWIPE_TIME) return;

            const absX = Math.abs(deltaX);
            const absY = Math.abs(deltaY);

            // Must have minimum distance
            if (absX < MIN_SWIPE_DISTANCE && absY < MIN_SWIPE_DISTANCE) {
                // Tap detected - use tap position relative to snake head
                handleTapDirection(touch.clientX, touch.clientY);
                return;
            }

            // Determine swipe direction
            if (absX > absY) {
                // Horizontal swipe
                if (deltaX > 0) {
                    setDirection({ x: 1, y: 0 }); // Right
                } else {
                    setDirection({ x: -1, y: 0 }); // Left
                }
            } else {
                // Vertical swipe
                if (deltaY > 0) {
                    setDirection({ x: 0, y: 1 }); // Down
                } else {
                    setDirection({ x: 0, y: -1 }); // Up
                }
            }

            // Visual feedback
            flashBorder();
        }

        function handleTapDirection(clientX, clientY) {
            const rect = canvas.getBoundingClientRect();
            const scaleX = GRID_SIZE / rect.width;
            const scaleY = GRID_SIZE / rect.height;

            const tapX = (clientX - rect.left) * scaleX;
            const tapY = (clientY - rect.top) * scaleY;

            const head = snake[0];
            const deltaX = tapX - head.x;
            const deltaY = tapY - head.y;

            if (Math.abs(deltaX) > Math.abs(deltaY)) {
                // Horizontal direction
                if (deltaX > 0) {
                    setDirection({ x: 1, y: 0 });
                } else {
                    setDirection({ x: -1, y: 0 });
                }
            } else {
                // Vertical direction
                if (deltaY > 0) {
                    setDirection({ x: 0, y: 1 });
                } else {
                    setDirection({ x: 0, y: -1 });
                }
            }

            flashBorder();
        }

        function flashBorder() {
            canvas.style.borderColor = '#fff';
            setTimeout(() => {
                if (isGameRunning) {
                    canvas.style.borderColor = '#00ff88';
                }
            }, 50);
        }

        // Attach touch events to entire document for better mobile experience
        document.addEventListener('touchstart', (e) => {
            if (e.target === canvas || e.target === document.body) {
                handleTouchStart(e);
            }
        }, { passive: false });

        document.addEventListener('touchmove', (e) => {
            if (e.target === canvas || e.target === document.body) {
                handleTouchMove(e);
            }
        }, { passive: false });

        document.addEventListener('touchend', (e) => {
            if (e.target === canvas || e.target === document.body) {
                handleTouchEnd(e);
            }
        }, { passive: false });

        // Prevent zoom and scroll on mobile
        document.addEventListener('gesturestart', e => e.preventDefault());
        document.addEventListener('gesturechange', e => e.preventDefault());
        document.addEventListener('gestureend', e => e.preventDefault());

        // Start button
        startBtn.addEventListener('click', startGame);
        startBtn.addEventListener('touchend', (e) => {
            e.preventDefault();
            e.stopPropagation();
            startGame();
        });

        // Initial draw
        draw();
    })();
    </script>
</body>
</html>
